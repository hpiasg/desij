/** * Copyright 2012 Stanislavs Golubcovs * * This file is part of DesiJ. *  * DesiJ is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * DesiJ is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with DesiJ.  If not, see <http://www.gnu.org/licenses/>. */options{	LOOKAHEAD = 3;	CHOICE_AMBIGUITY_CHECK = 2;	OTHER_AMBIGUITY_CHECK = 1;	STATIC = false;	DEBUG_PARSER = false;	DEBUG_LOOKAHEAD = false;	DEBUG_TOKEN_MANAGER = false;	ERROR_REPORTING = true;	JAVA_UNICODE_ESCAPE = false;	UNICODE_INPUT = false;	IGNORE_CASE = false;	USER_TOKEN_MANAGER = false;	USER_CHAR_STREAM = false;	BUILD_PARSER = true;	BUILD_TOKEN_MANAGER = true;	SANITY_CHECK = true;	FORCE_LA_CHECK = true;		JDK_VERSION = "1.5";}PARSER_BEGIN(HCExpressionParser)package net.strongdesign.balsa.hcexpressionparser;import net.strongdesign.balsa.hcexpressionparser.terms.*;import net.strongdesign.balsa.hcexpressionparser.terms.HCTerm.ExpansionType;import java.util.HashSet;public class HCExpressionParser implements HCChannelSenseController{		public int scale = 1;		private HashSet<String> scaled = new HashSet<String>();    private HashSet<String> acts = new HashSet<String>();    public boolean isActive(String name) {        return acts.contains(name);    }    public void setActive(String name, boolean act) {        if (act) {                acts.add(name);        } else {                acts.remove(name);        }    }    public boolean isScaled(String name) {        return scaled.contains(name);    }    public void setScaled(String name, boolean act) {        if (act) {        	scaled.add(name);        } else {        	scaled.remove(name);        }    }	  public static void main(String args []) throws ParseException  {  	    HCExpressionParser parser = new HCExpressionParser(System.in);           while (true)    {      System.out.println("Reading from standard input...");      try      {			HCTerm t = parser.HCParser();						if (t!=null) System.out.println(t.toString());            if (t==null) {              	System.out.println("NULL term returned");            } else {    			HCTerm up   = t.expand(ExpansionType.UP, parser.scale, parser, false);    			HCTerm down = t.expand(ExpansionType.DOWN, parser.scale, parser, false);    				    		if (up!=null) System.out.println("UP: "+up.toString());	    		else System.out.println("UP: null");	    		if (down!=null) System.out.println("DOWN: "+down.toString());	    		else System.out.println("DOWN: null");    			    		}      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        e.printStackTrace();                parser.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        e.printStackTrace();        break;      }    }      }}PARSER_END(HCExpressionParser)SKIP :{  " " | "\r"}TOKEN : {		<CHANNEL  : ["A"-"Z"]|(["0"-"9"])+>	|	<REQ      : ("r" <CHANNEL>) >	|	<ACK      : ("a" <CHANNEL>) >	|	<NACK     : ("n" <CHANNEL>) >	|	<INP      : ("i" <CHANNEL>) >	|	<INTER    : ("c" <CHANNEL>) >	|	<OUTP     : ("o" <CHANNEL>) >	|	<CONCUR   : "||" >	|	<CHOICE   : "|" >	|	<SEQUENCE : ";" >	|	<ENCLOSE  :	":" > // enclosure	|	<COMMA    : "," > // sync	|	<DOT	  : "." > // follow operator	|	<SYNCPROD : "**" > // synchronous product 	|	<UP       : "up" >	|	<DOWN     : "down" >	|	<OPEN_B   : "("|"[" >	|	<CLOSE_B  : ")"|"]" >	|	<EXPANSION  : "#||" | "#|" | "#;" | "#:" | "#," | "#." | "#**" > // expansions	|	<SHARP    : "#" >	|	<PLUS     : "+" >	|	<MINUS    : "-" >}HCTerm HCParser() :{		HCTerm t=null;	Token c;	String chan;	Token tk;	scaled.clear();}{	(	(						"\n"			|			(				"active"				(					c = <CHANNEL> { setActive(c.image, true); }					(						"," c = <CHANNEL> { setActive(c.image, true); }					)*				)			)			|			(				"passive"				(					c = <CHANNEL> { setActive(c.image, false); }					(						"," c = <CHANNEL> { setActive(c.image, false); }					)*				)			)			|			(				"scale" c = <CHANNEL> { scale = Integer.valueOf(c.image);} 			)			|			(				"scaled"				(					c = <CHANNEL> { setScaled(c.image, true); }					(						"," c = <CHANNEL> { setScaled(c.image, true); }					)*				)			)		)*		t=hcSyncProduct() ("\n")?		)	{		return t;	}}HCTerm hcSyncProduct() :{	HCInfixOperator io = new HCInfixOperator();	io.operation = HCInfixOperator.Operation.SYNCPROD;	HCTerm t;}{	(		t=hcChoice() {io.components.add(t);} (<SYNCPROD> t=hcChoice() {io.components.add(t);} )*	)	{		if (io.components.size()==1) return t;		return io;	}}HCTerm hcChoice() :{	HCInfixOperator io = new HCInfixOperator();	io.operation = HCInfixOperator.Operation.CHOICE;	HCTerm t;}{	(		t=hcConcur() {io.components.add(t);} (<CHOICE> t=hcConcur() {io.components.add(t);} )*	)	{		if (io.components.size()==1) return t;		return io;	}}HCTerm hcConcur() :{	HCInfixOperator io = new HCInfixOperator();	io.operation = HCInfixOperator.Operation.CONCUR;	HCTerm t;}{	(		t=hcSequence() {io.components.add(t);} (<CONCUR> t=hcSequence() {io.components.add(t);} )* 	)	{		if (io.components.size()==1) return t;		return io;	}}HCTerm hcSequence() :{	HCInfixOperator io = new HCInfixOperator();	io.operation = HCInfixOperator.Operation.SEQUENCE;	HCTerm t;}{	(		t=hcFollow() {io.components.add(t);} (<SEQUENCE> t=hcFollow() {io.components.add(t);} )* 	)	{		if (io.components.size()==1) return t;		return io;	}}HCTerm hcFollow() :{	HCInfixOperator io = new HCInfixOperator();	io.operation = HCInfixOperator.Operation.FOLLOW;	HCTerm t;}{	(		t=hcSync() {io.components.add(t);} (<DOT> t=hcSync() {io.components.add(t);} )* 	)	{		if (io.components.size()==1) return t;		return io;	}}HCTerm hcSync() :{	HCInfixOperator io = new HCInfixOperator();	io.operation = HCInfixOperator.Operation.SYNC;	HCTerm t;}{	(		t=hcLoop() {io.components.add(t);} (<COMMA> t=hcLoop() {io.components.add(t);} )* 	)	{		if (io.components.size()==1) return t;		return io;	}}HCTerm hcLoop() :{	HCLoopTerm lt = new HCLoopTerm();	HCTerm t;}{	(	<SHARP> t=hcBrackets() {lt.component = t; return lt;}	|	t=hcBrackets() {return t;}	)}HCTerm hcBrackets():{	HCTerm t;	Token tok;	HCTerm ret;	HCPhaseTerm p;}{	(		(<OPEN_B> t=hcSyncProduct() <CLOSE_B>)	|	(<UP>   <OPEN_B> t=hcSyncProduct() <CLOSE_B> {p = new HCPhaseTerm(); p.phase = ExpansionType.UP;   p.component=t; return p;})	|	(<DOWN> <OPEN_B> t=hcSyncProduct() <CLOSE_B> {p = new HCPhaseTerm(); p.phase = ExpansionType.DOWN; p.component=t; return p;})	|	(t=hcChannel())		|	(tok=<EXPANSION> t=hcBrackets()			{	ret = new HCExpansionTerm();				((HCExpansionTerm)ret).operation = HCInfixOperator.Operation.fromString(tok.image.substring(1));				((HCExpansionTerm)ret).component = t;				return ret;			}		)	)	{		return t;	}}HCTerm hcChannel():{	Token t;	HCTerm ret;	HCTerm tmp;	HCTerm comp;}{	(		(			t=<CHANNEL> {				ret = new HCChannelTerm();				((HCChannelTerm)ret).channel=t.image;			}			(<ENCLOSE> comp=hcBrackets() {				tmp = ret;				ret = new HCEnclosureTerm();				((HCEnclosureTerm)ret).channel = (HCChannelTerm)tmp;				((HCEnclosureTerm)ret).component = comp;			}			)?		)	|(	{ ret = new HCTransitionTerm(); 		}		(			t="~"			{				((HCTransitionTerm)ret).isDead = true;			}		)?		(				(t=<INP>				{						((HCTransitionTerm)ret).channel = ""+t.image.charAt(1);					((HCTransitionTerm)ret).wire = "i";				}			)		|	(t=<INTER>				{						((HCTransitionTerm)ret).channel = ""+t.image.charAt(1);					((HCTransitionTerm)ret).wire = "c";				}			)		|	(t=<OUTP>				{						((HCTransitionTerm)ret).channel = ""+t.image.charAt(1);					((HCTransitionTerm)ret).wire = "o";				}			)		|	(t=<REQ>				{						((HCTransitionTerm)ret).channel = ""+t.image.charAt(1);					((HCTransitionTerm)ret).wire = "r";				}			)		|	(t=<ACK>				{						((HCTransitionTerm)ret).channel = ""+t.image.charAt(1);					((HCTransitionTerm)ret).wire = "a";				} 			)		|	(t=<NACK>				{						((HCTransitionTerm)ret).channel = ""+t.image.charAt(1);					((HCTransitionTerm)ret).wire = "n";				}			)		)		(			((t=<PLUS>|t=<MINUS>)				{					((HCTransitionTerm)ret).direction=t.image;				}			)?		)				)	)	{		return ret;	}}