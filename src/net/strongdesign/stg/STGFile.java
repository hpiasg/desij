/**
 * Copyright 2004,2005,2006,2007,2008,2009,2010,2011 Mark Schaefer, Dominic Wist
 *
 * This file is part of DesiJ.
 * 
 * DesiJ is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * DesiJ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DesiJ.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * Created on 05.10.2004
 *
 */
package net.strongdesign.stg;

import java.io.StringReader;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import net.strongdesign.desij.CLW;
import net.strongdesign.desij.Messages;
import net.strongdesign.stg.parser.GParser;
import net.strongdesign.stg.parser.ParseException;
import net.strongdesign.stg.traversal.CollectorFactory;
import net.strongdesign.stg.traversal.Condition;
import net.strongdesign.stg.traversal.ConditionFactory;

/**
 * This class is for saving and loading STGs. Until now only the .g format is
 * supported as used e.g. by Petrify
 * 
 * check for parsing of freaky files
 * 
 * @author Mark Schaefer
 *  
 */

public abstract class STGFile {
	
	
	private static final String signalPrefix = "_";
	
	public static String convertToDot(STG stg, Collection<Node> nodes, String l) {
		
		//result contains the content of the file to be written at the and of the method
		StringBuilder result = new StringBuilder();
		
		//ehre, wem ehre gebuehrt :-)
		result.append("/*Generated by DesiJ "+new Date() + "*/\n");
		result.append("/*(c) 2004-2007 by Mark Schaefer, University of Augsburg, www.uni-augsburg.de */\n");
		result.append("/*Number of places: " + stg.getNumberOfPlaces() + "  Number of Transitions: " + stg.getNumberOfTransitions() +"*/\n\n");
		
		//now the *.g stuff
		result.append(	"\ndigraph {\nsize=\"7,10\"\n"+"" +
						"center=true\n"+"" +
						"labelloc=bottom\n"+
						"concentrate=false\n"
					);
		
		result.append("label=\"" + l + "\\nGenerated by DesiJ - "+new Date()+"\"\n");
		
		for (Place place : stg.getPlaces(ConditionFactory.ALL_PLACES  )) {
			if (place.getMarking()>0 || !ConditionFactory.MARKED_GRAPH_PLACE.fulfilled(place) || nodes.contains(place)) {
				String marking = place.getMarking()>0?""+place.getMarking():"";
				if (nodes.contains(place))
					result.append("\""+place.getIdentifier() +"\" [shape=circle, peripheries=2, label=\""+ marking +"\" ]\n");
				else
					result.append("\""+place.getIdentifier() +"\" [shape=circle, label=\""+ marking +"\" ]\n");
				
				for (Node child : place.getChildren()) {
					result.append("\""+place.getIdentifier() +"\"");
					if (place.getChildValue(child)>1) {
						int w = place.getChildValue(child);
						result.append(" -> \"" + child.getIdentifier() + "\" [style=\"setlinewidth("+w+")\",label=\""+w+"\"]\n");
					}
					else
						result.append(" -> \"" + child.getIdentifier() +"\" \n");
				}
				result.append("\n"); 
			}
		}
		for (Transition transition : stg.getTransitions(ConditionFactory.ALL_TRANSITIONS)  )	{
			String style=null;
			String label=transition.getString(Node.UNIQUE);
			
			Signature sig = stg.getSignature(transition.getLabel().getSignal()); 
			if (sig==Signature.DUMMY) { 
				style="height=0,fontsize=10,";
				label=transition.getString(Node.UNIQUE);
			}
			if (sig==Signature.INPUT)
				style="height=0.25,style=bold,color=red,";
			if (sig==Signature.OUTPUT)
				style="height=0.25,color=blue,";
			if (sig==Signature.INTERNAL)
				style="height=0.25,color=green,style=rounded,";
			
			if (nodes.contains(transition))
				result.append("\""+transition.getIdentifier() +
						"\"  ["+style+"shape=rectangle,peripheries=2,label=\"" +label+    "\"]\n ");
			else
				result.append("\""+transition.getIdentifier() +
					"\"  ["+style+"shape=rectangle,label=\"" +label+    "\"]\n ");
			
			for (Node child : transition.getChildren()) {
				result.append("\""+transition.getIdentifier()+"\"" );
				if (ConditionFactory.MARKED_GRAPH_PLACE.fulfilled((Place)child) && ((Place)child).getMarking()==0 && !nodes.contains(child))
					if ( transition.getChildValue(child.getChildren().iterator().next())>1 )
						result.append(" -> \"" + child.getChildren().iterator().next().getIdentifier() + 
								"\" [label=\""+transition.getChildValue(child.getChildren().iterator().next())+"\"]\n");
					else
						result.append(" -> \"" + child.getChildren().iterator().next().getIdentifier()+"\"" );
				
				else
					if (transition.getChildValue(child)>1) {
						int w = transition.getChildValue(child);
						result.append(" -> \"" + child.getIdentifier() + 
								"\" [style=\"setlinewidth("+w+")\",label=\""+transition.getChildValue(child)+"\"]\n");
					}
						
					else
						result.append(" -> \"" + child.getIdentifier() + "\" \n");
				
				
				result.append("\n"); 
			}
			
		}
		
		result.append(" }"); 
		
		return result.toString();
		
	}
	

	/**
	 * Converts a *.g file to the internal representation. For this, a JavaCC generated parser is used.
	 * @param file
	 * @return
	 * @throws ParseException
	 * @throws STGException 
	 */
	
	public static STG convertToSTG(String file, boolean withCoordinates) throws  ParseException, STGException {
		GParser parser = new GParser(new StringReader(file));
		STG result = parser.STG(withCoordinates);
		result.clearUndoStack();
		return result;
	}
	
	
	public static String  convertToG(STG stg) {
		return convertToG(stg, true, false);
	}
	
	public static String convertToG(STG stg, boolean withSignalNames) {
		return convertToG(stg, withSignalNames, false);
	}
	
	public static String convertToG(STG stg, boolean withSignalNames, boolean implicitPlaces) {
			
		boolean implicit = implicitPlaces || CLW.instance.SAVE_ALL_PLACES.isEnabled();
		
		
		if (CLW.instance.REMOVE_REDUNDANT_BEFORE_SAVE.isEnabled()) {
			STGUtil.removeRedundantPlaces(stg, true);
		}
		
		//collect all implicit places which have to made explicit
		List<Place> explicit = new LinkedList<Place>();
		Condition<Place> mgPlace = ConditionFactory.MARKED_GRAPH_PLACE;
		for (Place place : stg.getPlaces(ConditionFactory.ALL_PLACES)) {
			if (! mgPlace.fulfilled(place)) continue;
			for (Node neighbour : place.getSibblings()) {
				Place nPlace = (Place) neighbour;
				// over cautious, some places might be added altough it is unneccessary
				if ( place.getParents().equals(nPlace.getParents()) &&   
						place.getChildren().equals(nPlace.getChildren())) {
					explicit.add(place);
					explicit.add(nPlace);
				}
			}
		}
		
		//result contains the file to be written at the and of the method
		StringBuilder result = new StringBuilder();
		
		
		// ALL THE GLORY TO THE HYPNOTOAD
		result.append(Messages.getString("STGFile.stg_start_comment")+new Date() + "\n"); 
		result.append("#Number of places: " + stg.getNumberOfPlaces() + "  Number of Transitions: " + stg.getNumberOfTransitions() +"\n\n");
		
		//now the *.g stuff
			
		//the different signals	
		for (Signature signature : Signature.values()) {
			if (signature == Signature.ANY) continue;
			
			Set<Integer> signals = new HashSet<Integer>(stg.collectFromTransitions(
					ConditionFactory.getSignatureOfCondition(signature), 
					CollectorFactory.getSignalCollector()));

			if (! signals.isEmpty()) {
				result.append(signature.getGFormatName() + " "); 
				for (Integer signal : signals) {
					if (withSignalNames) {
						result.append(stg.getSignalName(signal));
					}
					else {
						result.append(signalPrefix + signal);
					}
					
					result.append(" ");
				}
					 
				result.append("\n"); 
			}
		}
		
		
		
		result.append("\n.graph\n"); 
		
		for (Place place : stg.getPlaces(ConditionFactory.ALL_PLACES  )) { 
			if (implicit || !mgPlace.fulfilled(place) || explicit.contains(place) )
			{
				result.append(place.getString(Node.UNIQUE) );
				for (Node child : place.getChildren()) {
					result.append(" ");
					if (withSignalNames) {
						result.append(child.getString(Node.UNIQUE));
					}
					else {						
						result.append(signalPrefix + ((Transition) child).getLabel() + "/" + child.getIdentifier());
					}						
						
					if (place.getChildValue(child)>1)
						 result.append("("+place.getChildValue(child)+")");
				}
				
				result.append("\n"); 
			}
		}
			
		for (Transition transition : stg.getTransitions(ConditionFactory.ALL_TRANSITIONS)  ) {	
			if (withSignalNames) {
				result.append(transition.getString(Node.UNIQUE));
			}
			else {						
				result.append(signalPrefix + transition.getLabel() + "/" + transition.getIdentifier());
			}						

			for (Node child : transition.getChildren())
				if (!implicit && mgPlace.fulfilled((Place)child) && !explicit.contains(child)) {
					Transition t = (Transition) child.getChildren().iterator().next();
					result.append(" ");
					if (withSignalNames) {
						result.append(t.getString(Node.UNIQUE));
					}
					else {						
						result.append(signalPrefix + t.getLabel() + "/" + t.getIdentifier());
					}		
					
				}
				else {
					result.append(" " + child.getString(Node.UNIQUE));
					if (transition.getChildValue(child)>1)
						result.append("("+transition.getChildValue(child)+")");
				}
			
			result.append("\n"); 
		}
		
		
		//capacity removed due to new project csc aware decomposition
	/*	result.append("\n\n.capacity ");
		for (Place place : stg.getPlaces(ConditionFactory.getAll())  ) 
			if (implicit || !ConditionFactory.getMarkedGraphPlaceCondition().fulfilled(place) || explicit.contains(place))
				result.append(" " + place.getString(Node.UNIQUE) + "=128 " ); 
			else
				result.append(" <" + place.getParents().iterator().next().getString(Node.UNIQUE) + "," + 
						place.getChildren().iterator().next().getString(Node.UNIQUE) +">" + "=128 "); 
		
	*/
		result.append("\n\n.marking {"); 
		
		
		for (Place place : stg.getPlaces(ConditionFactory.ALL_PLACES)  ) 
			if (place.getMarking()>0) {
				String marking = place.getMarking()==1?"":"="+place.getMarking();
				if (implicit || !mgPlace.fulfilled(place) || explicit.contains(place))
					result.append(" " + place.getString(Node.UNIQUE)  ); 
				else {
					result.append(" <" );
					if (withSignalNames) {
						result.append( 	place.getParents().iterator().next().getString(Node.UNIQUE) + "," + 
								place.getChildren().iterator().next().getString(Node.UNIQUE));
					}
					else {
						Transition t1 = (Transition) place.getParents().iterator().next();
						Transition t2 = (Transition) place.getChildren().iterator().next();
						result.append(signalPrefix + t1.getLabel() + "/" + t1.getIdentifier());
						result.append(",");
						result.append(signalPrefix + t2.getLabel() + "/" + t2.getIdentifier());
					}
					result.append( ">");
				}
				result.append(marking);
			}
		
		
		result.append(" }\n.end\n"); 
		
		return result.toString();
		
		
	}
	
	
	
}




